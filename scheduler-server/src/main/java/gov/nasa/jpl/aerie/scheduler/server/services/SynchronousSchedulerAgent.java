package gov.nasa.jpl.aerie.scheduler.server.services;

import gov.nasa.jpl.aerie.merlin.driver.MissionModelLoader;
import gov.nasa.jpl.aerie.merlin.protocol.types.SerializedValue;
import gov.nasa.jpl.aerie.merlin.server.exceptions.NoSuchPlanException;
import gov.nasa.jpl.aerie.scheduler.GlobalConstraint;
import gov.nasa.jpl.aerie.scheduler.Goal;
import gov.nasa.jpl.aerie.scheduler.HuginnConfiguration;
import gov.nasa.jpl.aerie.scheduler.MissionModelWrapper;
import gov.nasa.jpl.aerie.scheduler.Plan;
import gov.nasa.jpl.aerie.scheduler.PlanInMemory;
import gov.nasa.jpl.aerie.scheduler.PrioritySolver;
import gov.nasa.jpl.aerie.scheduler.Problem;
import gov.nasa.jpl.aerie.scheduler.Solver;
import gov.nasa.jpl.aerie.scheduler.server.ResultsProtocol;
import gov.nasa.jpl.aerie.scheduler.server.exceptions.ResultsProtocolFailure;
import gov.nasa.jpl.aerie.scheduler.server.models.PlanMetadata;

import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * agent that handles posed scheduling requests by blocking the requester thread until scheduling is complete
 *
 * @param merlinService interface for querying plan details from merlin
 */
//TODO: will eventually need scheduling goal service arg to pull goals from scheduler's own data store
public record SynchronousSchedulerAgent(MerlinService merlinService)
    implements SchedulerAgent
{
  public SynchronousSchedulerAgent {
    Objects.requireNonNull(merlinService);
  }

  /**
   * {@inheritDoc}
   *
   * consumes any ResultsProtocolFailure exception generated by the scheduling process and writes its message as a
   * failure reason to the given output port (eg aerie could not be reached, mission model could not be loaded from jar
   * file, requested plan revision has changed in the database, scheduler could not find a solution, etc)
   *
   * any remaining exceptions passed upward represent fatal service configuration problems
   */
  @Override
  public void schedule(final ScheduleRequest request, final ResultsProtocol.WriterRole writer) {
    try {
      //confirm requested plan to schedule from/into still exists at targeted version (request could be stale)
      //TODO: maybe some kind of high level db transaction wrapping entire read/update of target plan revision
      final var planMetadata = getMerlinPlanMetadata(request.planId());
      ensureRevisionMatch(request, planMetadata);

      //create scheduler problem seeded with initial plan
      final var problem = createProblem(planMetadata);
      final var scheduler = createScheduler(planMetadata, problem);

      //run the scheduler to find a solution to the posed problem, if any
      final var solutionPlan = scheduler.getNextSolution().orElseThrow(
          () -> new ResultsProtocolFailure("scheduler returned no solution"));

      //store the solution plan back into merlin (and reconfirm no intervening mods!)
      //TODO: make revision confirmation atomic part of plan mutation (plan might have been modified during scheduling!)
      ensureRevisionMatch(request, getMerlinPlanMetadata(request.planId()));
      storeFinalPlan(planMetadata, solutionPlan);

      //collect results and notify subscribers of success
      final var results = collectResults(solutionPlan);
      writer.succeedWith(results);
    } catch (final ResultsProtocolFailure e) {
      //unwrap failure message from any anticipated exceptions and forward to subscribers
      writer.failWith(e.getMessage());
    }
  }

  /**
   * fetch all necessary details about the target plan from aerie services
   *
   * @param planId identifier of the target plan to load metadata for
   * @return snapshot of current metadata for target plan from merlin
   * @throws ResultsProtocolFailure when the requested plan cannot be found, or aerie could not be reached
   */
  private PlanMetadata getMerlinPlanMetadata(final String planId) {
    try {
      return merlinService.getPlanMetadata(planId);
    } catch (NoSuchPlanException e) {
      throw new ResultsProtocolFailure(e);
    }
  }

  /**
   * confirms that plan revisions match
   *
   * @param request the original request for scheduling, containing an intended starting plan revision
   * @param planMetadata snapshot of plan metadata, containing the actual plan revision
   * @throws ResultsProtocolFailure when the requested plan revision does not match the actual revision
   */
  private void ensureRevisionMatch(final ScheduleRequest request, PlanMetadata planMetadata) {
    if (planMetadata.planRev() != request.planRev()) {
      throw new ResultsProtocolFailure("plan with id %s is no longer at revision %s".formatted(
          request.planId(), request.planRev()));
    }
  }

  /**
   * creates a fully specified scheduler problem statement based on target merlin plan
   *
   * @param planMetadata metadata of the plan container to load from
   * @return a problem specification ready for passing to the scheduler
   */
  private Problem createProblem(PlanMetadata planMetadata) {
    final var mission = loadMissionModel(planMetadata);
    final var problem = new Problem(mission);

    //seed the problem with the intial plan contents
    problem.setInitialPlan(loadInitialPlan(planMetadata, mission));

    //apply constraints/goals to the problem
    loadConstraints(planMetadata, mission).forEach(problem.getMissionModel()::add);
    loadGoals(planMetadata, mission).forEach(problem::add);

    return problem;
  }

  /**
   * collects the scheduling goals that apply to the current scheduling run on the target plan
   *
   * @param planMetadata details of the plan container whose associated goals should be collected
   * @param mission the mission model that the plan adheres to, possibly associating additional relevant goals
   * @return the list of goals relevant to the target plan
   * @throws ResultsProtocolFailure when the constraints could not be loaded, or the data stores could not be
   *     reached
   */
  private List<GlobalConstraint> loadConstraints(PlanMetadata planMetadata, MissionModelWrapper mission) {
    //TODO: is the plan and mission model enough to find the relevant constraints? (eg what about sandbox toggling?)
    //TODO: load global constraints from scheduler data store?
    //TODO: load activity type constraints from somewhere (scheduler store? mission model?)
    //TODO: somehow apply user control over which constraints to enforce during scheduling
    return List.of();
  }

  /**
   * collects the scheduling goals that apply to the current scheduling run on the target plan
   *
   * @param planMetadata details of the plan container whose associated goals should be collected
   * @param mission the mission model that the plan adheres to, possibly associating additional relevant goals
   * @return the list of goals relevant to the target plan
   * @throws ResultsProtocolFailure when the goals could not be loaded, or the goal data store could not be reached
   */
  private List<Goal> loadGoals(PlanMetadata planMetadata, MissionModelWrapper mission) {
    //TODO: is the plan and mission model enough to find the relevant goals? (eg what about sandbox goals?)
    //TODO: (v0.10.0) load scheduling goals from hardcoded jar into problem
    //TODO: (future) load scheduling goals from scheduler data store into problem
    //TODO: somehow apply user control over which scheduling rules to actually run vs just check
    return List.of();
  }

  /**
   * create a scheduler that is tuned to solve the posed problem
   *
   * @param planMetadata details of the plan container that scheduling is occurring from/into
   * @param problem specification of the scheduling problem that needs to be solved
   * @return a new scheduler that is set up to begin providing solutions to the problem
   */
  private Solver createScheduler(PlanMetadata planMetadata, Problem problem) {
    final var config = new HuginnConfiguration();
    //TODO: move temporal focus from sched config into Problem object
    //TODO: allow for separate control of windows for constraint analysis vs ability to schedule activities
    //      (eg constraint may need view into immutable past to know how to schedule things in the future)
    config.setHorizon(planMetadata.horizon());
    return new PrioritySolver(config, problem);
  }

  /**
   * load the activity instance content of the specified merlin plan into scheduler-ready objects
   *
   * @param planMetadata metadata of plan container to load from
   * @param mission the mission model that the plan adheres to
   * @return a plan with all activity instances loaded from the target merlin plan container
   * @throws ResultsProtocolFailure when the requested plan cannot be loaded, or the target plan revision has
   *     changed, or aerie could not be reached
   */
  private Plan loadInitialPlan(PlanMetadata planMetadata, MissionModelWrapper mission) {
    final var schedPlan = new PlanInMemory(mission);
    //TODO: leverage forthcoming AERIE-1555 graphql query to parse plan into scheduler objects
    return schedPlan;
  }

  /**
   * creates an instance of the mission model referenced by the specified plan
   *
   * @param plan metadata of the target plan indicating which mission model to load
   * @return instance of the mission model to extract any activity types, constraints, and simulations from
   * @throws ResultsProtocolFailure when the mission model could not be loaded: eg jar file not found, declared
   *     version/name in jar does not match, or aerie filesystem could not be mounted
   */
  private MissionModelWrapper loadMissionModel(PlanMetadata plan) {
    try {
      //TODO: somehow allow for user configuration of model (probably part of request body?)
      final var missionConfig = SerializedValue.of(Map.of());

      final var aerieModel = MissionModelLoader.loadMissionModel(
          missionConfig, plan.modelPath(), plan.modelName(), plan.modelVersion());

      //TODO: unify model containers to avoid wrappers
      return new MissionModelWrapper(aerieModel, plan.horizon());
    } catch (MissionModelLoader.MissionModelLoadException e) {
      throw new ResultsProtocolFailure(e);
    }
  }

  /**
   * place the modified activity plan back into the target merlin plan container
   *
   * this will obsolete the locally cached planMetadata since the plan revision will change!
   *
   * @param planMetadata metadata of plan container to store into; outdated after return
   * @param plan plan with all activity instances that should be stored to target merlin plan container
   * @throws ResultsProtocolFailure when the plan could not be stored to aerie, the target plan revision has
   *     changed, or aerie could not be reached
   */
  private void storeFinalPlan(PlanMetadata planMetadata, Plan plan) {
    //TODO: leverage forthcoming AERIE-1555 graphql mutation to store scheduler objects into plan
  }

  /**
   * collect output summary of the scheduling run
   *
   * depending on service configuration, this result may be cached and served to later requesters
   *
   * only reports one evaluation's score per goal, even if the goal is scored in multiple evaluations
   *
   * @param plan the target plan after the scheduling run has completed
   * @return summary of the state of the plan after scheduling ran; eg goal success metrics, associated instances, etc
   */
  private ScheduleResults collectResults(Plan plan) {
    final var activityCount = plan.getActivitiesByType().size();

    final var goalScores = plan
        .getEvaluations()
        .stream().flatMap(eval -> eval.getGoalEvaluations().entrySet().stream())
        .collect(Collectors.toMap(
            e -> e.getKey().getName(), //create score map keyed by goal name
            e -> e.getValue().getScore(),
            (a, b) -> a)); //just replace any duplicate goal name scores

    return new ScheduleResults(activityCount, goalScores);
  }

}
