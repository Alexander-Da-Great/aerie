/**********
SCHEDULING CONDITION
***********/
/*
RESTORE ORIGINAL
*/
create table scheduling_condition (
  id integer generated by default as identity,
  revision integer not null default 0,
  name text not null,
  definition text not null,

  model_id integer not null,
  description text not null default '',
  author text null,
  last_modified_by text null,
  created_date timestamptz not null default now(),
  modified_date timestamptz not null default now(),

  constraint scheduling_condition_synthetic_key
    primary key (id)
);

comment on table scheduling_condition is e''
  'A condition restricting scheduling of a plan.';
comment on column scheduling_condition.id is e''
  'The synthetic identifier for this scheduling condition.';
comment on column scheduling_condition.revision is e''
  'A monotonic clock that ticks for every change to this scheduling condition.';
comment on column scheduling_condition.definition is e''
  'The source code for a Typescript module defining this scheduling condition';
comment on column scheduling_condition.model_id is e''
  'The mission model used to which this scheduling condition is associated.';
comment on column scheduling_condition.name is e''
  'A short human readable name for this condition';
comment on column scheduling_condition.description is e''
  'A longer text description of this scheduling condition.';
comment on column scheduling_condition.author is e''
  'The original user who authored this scheduling condition.';
comment on column scheduling_condition.last_modified_by is e''
  'The last user who modified this scheduling condition.';
comment on column scheduling_condition.created_date is e''
  'The date this scheduling condition was created.';
comment on column scheduling_condition.modified_date is e''
  'The date this scheduling condition was last modified.';

create function update_logging_on_update_scheduling_condition()
  returns trigger
  security definer
language plpgsql as $$begin
  new.revision = old.revision + 1;
  new.modified_date = now();
return new;
end$$;

create trigger update_logging_on_update_scheduling_condition_trigger
  before update on scheduling_condition
  for each row
  when (pg_trigger_depth() < 1)
  execute function update_logging_on_update_scheduling_condition();

/*
DATA MIGRATION
*/
-- Conditions not on a model spec will not be kept, as the scheduler DB can't get the model id from the plan id
-- Because there is no uniqueness constraint on Scheduling Conditions when it comes to specifications, the ids can be preserved
with specified_definition(condition_id, condition_revision, model_id, definition, definition_creation) as (
 select cd.condition_id, cd.revision, s.model_id, cd.definition, cd.created_at
      from scheduling_model_specification_conditions s
      left join scheduling_condition_definition cd using (condition_id)
      where ((s.condition_revision is not null and s.condition_revision = cd.revision)
      or (s.condition_revision is null and cd.revision = (select def.revision
                                                      from scheduling_condition_definition def
                                                      where def.condition_id = s.condition_id
                                                      order by def.revision desc limit 1)))
)
insert into scheduling_condition(id, revision, name, definition, model_id, description,
                                 author, last_modified_by, created_date, modified_date)
select m.id, sd.condition_revision, m.name, sd.definition, sd.model_id, m.description,
       m.owner, m.updated_by, m.updated_at, greatest(m.updated_at::timestamptz, sd.definition_creation::timestamptz)
  from scheduling_condition_metadata m
  inner join specified_definition sd on m.id = sd.condition_id;

/*
POST DATA MIGRATION TABLE CHANGES
*/
drop trigger set_timestamp on scheduling_condition_metadata;
drop function scheduling_condition_metadata_set_updated_at();

alter table scheduling_condition
  alter column id set generated always;
/*
SPECIFICATIONS
*/
drop trigger increment_revision_on_condition_delete on scheduling_specification_conditions;
drop function increment_spec_revision_on_conditions_spec_delete();
drop trigger increment_revision_on_condition_update on scheduling_specification_conditions;
drop function increment_spec_revision_on_conditions_spec_update();

alter table scheduling_specification_conditions
  drop constraint scheduling_specification_condition_definition_exists,
  drop constraint scheduling_specification_condition_exists,
  add constraint scheduling_specification_conditions_references_scheduling_conditions
    foreign key (condition_id)
      references scheduling_condition
      on update cascade
      on delete cascade,
  drop constraint scheduling_specification_conditions_specification_exists,
  add constraint scheduling_specification_conditions_references_scheduling_specification
    foreign key (specification_id)
      references scheduling_specification
      on update cascade
      on delete cascade,
  drop column condition_revision;

comment on table scheduling_specification_conditions is e''
  'A join table associating scheduling specifications with scheduling conditions.';
comment on column scheduling_specification_conditions.specification_id is e''
  'The ID of the scheduling specification a scheduling goal is associated with.';
comment on column scheduling_specification_conditions.condition_id is e''
  'The ID of the condition a scheduling specification is associated with.';
comment on column scheduling_specification_conditions.enabled is null;

drop table scheduling_model_specification_conditions;

/*
TAGS
*/
drop table metadata.scheduling_condition_definition_tags;
drop table metadata.scheduling_condition_tags;

/*
DEFINITION
*/
drop trigger scheduling_goal_definition_set_revision on scheduling_condition_definition;
drop function scheduling_condition_definition_set_revision();
drop table scheduling_condition_definition;

/*
METADATA
*/
drop index condition_name_unique_if_published;
drop table scheduling_condition_metadata;

call migrations.mark_migration_rolled_back('13');
