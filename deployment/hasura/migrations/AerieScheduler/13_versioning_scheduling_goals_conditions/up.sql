/**********
SCHEDULING CONDITION
***********/
/*
METADATA
*/
create table scheduling_condition_metadata (
  id integer generated by default as identity,

  name text not null,
  description text not null default '',
  public boolean not null default false,

  owner text,
  updated_by text,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  constraint scheduling_condition_metadata_pkey
    primary key (id)
);

-- A partial index is used to enforce name uniqueness only on conditions visible to other users
create unique index condition_name_unique_if_published on scheduling_condition_metadata (name) where public;

comment on table scheduling_condition_metadata is e''
  'A condition restricting scheduling of a plan.';
comment on column scheduling_condition_metadata.id is e''
  'The unique identifier for this scheduling condition.';
comment on column scheduling_condition_metadata.name is e''
  'A short human readable name for this condition';
comment on column scheduling_condition_metadata.description is e''
  'A longer text description of this scheduling condition.';
comment on column scheduling_condition_metadata.public is e''
  'Whether this goal is visible to all users.';
comment on column scheduling_condition_metadata.owner is e''
  'The user responsible for this condition.';
comment on column scheduling_condition_metadata.updated_by is e''
  'The user who last modified this condition''s metadata.';
comment on column scheduling_condition_metadata.created_at is e''
  'The time at which this condition was created.';
comment on column scheduling_condition_metadata.updated_at is e''
  'The time at which this condition''s metadata was last modified.';

/*
DEFINITION
*/
create table scheduling_condition_definition(
  condition_id integer not null,
  revision integer not null default 0,
  definition text not null,
  author text,
  created_at timestamptz not null default now(),

  constraint scheduling_condition_definition_pkey
    primary key (condition_id, revision),
  constraint scheduling_condition_definition_condition_exists
    foreign key (condition_id)
    references scheduling_condition_metadata
    on update cascade
    on delete cascade
);

comment on table scheduling_condition_definition is e''
  'The specific revisions of a scheduling condition''s definition';
comment on column scheduling_condition_definition.revision is e''
  'An identifier of this definition.';
comment on column scheduling_condition_definition.definition is e''
  'An executable expression in the Merlin scheduling language.';
comment on column scheduling_condition_definition.author is e''
  'The user who authored this revision.';
comment on column scheduling_condition_definition.created_at is e''
  'When this revision was created.';

create function scheduling_condition_definition_set_revision()
returns trigger
volatile
language plpgsql as $$
declare
  max_revision integer;
begin
  -- Grab the current max value of revision, or -1, if this is the first revision
  select coalesce((select revision
  from scheduling_condition_definition
  where condition_id = new.condition_id
  order by revision desc
  limit 1), -1)
  into max_revision;

  new.revision = max_revision + 1;
  return new;
end
$$;

create trigger scheduling_goal_definition_set_revision
  before insert on scheduling_condition_definition
  for each row
  execute function scheduling_condition_definition_set_revision();

/*
TAGS
*/
create table metadata.scheduling_condition_tags (
  condition_id integer references public.scheduling_condition_metadata
    on update cascade
    on delete cascade,
  tag_id integer not null,
  primary key (condition_id, tag_id)
);
comment on table metadata.scheduling_condition_tags is e''
  'The tags associated with a scheduling condition.';

create table metadata.scheduling_condition_definition_tags (
  condition_id integer not null,
  condition_revision integer not null,
  tag_id integer not null,
  primary key (condition_id, condition_revision, tag_id),
  foreign key (condition_id, condition_revision) references scheduling_condition_definition
    on update cascade
    on delete cascade
);

comment on table metadata.scheduling_condition_definition_tags is e''
  'The tags associated with a specific scheduling condition definition.';

/*
SPECIFICATIONS
*/
create table scheduling_model_specification_conditions(
  model_id integer not null,
  condition_id integer not null,
  condition_revision integer, -- latest is NULL

  primary key (model_id, condition_id),
  foreign key (condition_id)
    references scheduling_condition_metadata
    on update cascade
    on delete restrict,
  foreign key (condition_id, condition_revision)
    references scheduling_condition_definition
    on update cascade
    on delete restrict
);

comment on table scheduling_model_specification_conditions is e''
'The set of scheduling conditions that all plans using the model should include in their scheduling specification.';
comment on column scheduling_model_specification_conditions.model_id is e''
'The model which this specification is for. Half of the primary key.';
comment on column scheduling_model_specification_conditions.condition_id is e''
'The id of a specific scheduling condition in the specification. Half of the primary key.';
comment on column scheduling_model_specification_conditions.condition_revision is e''
'The version of the scheduling condition definition to use. Leave NULL to use the latest version.';

alter table scheduling_specification_conditions
  add column condition_revision integer,
  -- This constraint's name is too long
  drop constraint scheduling_specification_conditions_references_scheduling_specification,
  add constraint scheduling_specification_conditions_specification_exists
    foreign key (specification_id)
     references scheduling_specification
     on update cascade
     on delete cascade,
  drop constraint scheduling_specification_conditions_references_scheduling_conditions,
  add constraint scheduling_specification_condition_exists
    foreign key (condition_id)
      references scheduling_condition_metadata
      on update cascade
      on delete restrict,
  add constraint scheduling_specification_condition_definition_exists
    foreign key (condition_id, condition_revision)
     references scheduling_condition_definition
     on update cascade
     on delete restrict;

comment on table scheduling_specification_conditions is e''
  'The set of scheduling conditions to be used on a given plan.';
comment on column scheduling_specification_conditions.specification_id is e''
  'The plan scheduling specification which this condition is on. Half of the primary key.';
comment on column scheduling_specification_conditions.condition_id is e''
  'The ID of a specific condition in the specification. Half of the primary key.';
comment on column scheduling_specification_conditions.condition_revision is e''
  'The version of the condition definition to use. Leave NULL to use the latest version.';
comment on column scheduling_specification_conditions.enabled is e''
  'Whether to use a given condition. Defaults to TRUE.';

create function increment_spec_revision_on_conditions_spec_update()
  returns trigger
  security definer
language plpgsql as $$
begin
  update scheduling_specification
  set revision = revision + 1
  where id = new.specification_id;
  return new;
end;
$$;

create trigger increment_revision_on_condition_update
  before insert or update on scheduling_specification_conditions
  for each row
  execute function increment_spec_revision_on_conditions_spec_update();

create function increment_spec_revision_on_conditions_spec_delete()
  returns trigger
  security definer
language plpgsql as $$
begin
  update scheduling_specification
  set revision = revision + 1
  where id = new.specification_id;
  return new;
end;
$$;

create trigger increment_revision_on_condition_delete
  before delete on scheduling_specification_conditions
  for each row
  execute function increment_spec_revision_on_conditions_spec_delete();

/*
DATA MIGRATION
*/
insert into scheduling_condition_metadata(id, name, description, public, owner, updated_by, created_at, updated_at)
select id, name, description, false, author, last_modified_by, created_date, modified_date
from scheduling_condition;

insert into scheduling_condition_definition(condition_id, definition, author, created_at)
select id, definition, author, modified_date
from scheduling_condition;

insert into scheduling_model_specification_conditions(model_id, condition_id)
select model_id, id
from scheduling_condition;

/*
POST DATA MIGRATION TABLE CHANGES
*/
alter table scheduling_condition_metadata
  alter column id set generated always;

create function scheduling_condition_metadata_set_updated_at()
returns trigger
security definer
language plpgsql as $$begin
  new.updated_at = now();
  return new;
end$$;

create trigger set_timestamp
before update on scheduling_condition_metadata
for each row
execute function scheduling_condition_metadata_set_updated_at();

/*
DROP ORIGINAL
*/
drop trigger update_logging_on_update_scheduling_condition_trigger on scheduling_condition;
drop function update_logging_on_update_scheduling_condition();
drop table scheduling_condition;

call migrations.mark_migration_applied('13');
